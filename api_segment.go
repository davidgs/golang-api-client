/*
Pinot Controller API

APIs for accessing Pinot Controller information

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// SegmentApiService SegmentApi service
type SegmentApiService service

type ApiDeleteAllSegmentsRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	type_ *string
	retention *string
}

// OFFLINE|REALTIME
func (r ApiDeleteAllSegmentsRequest) Type_(type_ string) ApiDeleteAllSegmentsRequest {
	r.type_ = &type_
	return r
}

// Retention period for the table segments (e.g. 12h, 3d); If not set, the retention period will default to the first config that&#39;s not null: the table config, then to cluster setting, then &#39;7d&#39;. Using 0d or -1d will instantly delete segments without retention
func (r ApiDeleteAllSegmentsRequest) Retention(retention string) ApiDeleteAllSegmentsRequest {
	r.retention = &retention
	return r
}

func (r ApiDeleteAllSegmentsRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.DeleteAllSegmentsExecute(r)
}

/*
DeleteAllSegments Delete all segments

Delete all segments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiDeleteAllSegmentsRequest
*/
func (a *SegmentApiService) DeleteAllSegments(ctx context.Context, tableName string) ApiDeleteAllSegmentsRequest {
	return ApiDeleteAllSegmentsRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *SegmentApiService) DeleteAllSegmentsExecute(r ApiDeleteAllSegmentsRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.DeleteAllSegments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	if r.retention != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retention", r.retention, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSegmentRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	segmentName string
	retention *string
}

// Retention period for the table segments (e.g. 12h, 3d); If not set, the retention period will default to the first config that&#39;s not null: the table config, then to cluster setting, then &#39;7d&#39;. Using 0d or -1d will instantly delete segments without retention
func (r ApiDeleteSegmentRequest) Retention(retention string) ApiDeleteSegmentRequest {
	r.retention = &retention
	return r
}

func (r ApiDeleteSegmentRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.DeleteSegmentExecute(r)
}

/*
DeleteSegment Delete a segment

Delete a segment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @param segmentName Name of the segment
 @return ApiDeleteSegmentRequest
*/
func (a *SegmentApiService) DeleteSegment(ctx context.Context, tableName string, segmentName string) ApiDeleteSegmentRequest {
	return ApiDeleteSegmentRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
		segmentName: segmentName,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *SegmentApiService) DeleteSegmentExecute(r ApiDeleteSegmentRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.DeleteSegment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}/{segmentName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segmentName"+"}", url.PathEscape(parameterValueToString(r.segmentName, "segmentName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.retention != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retention", r.retention, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSegmentsRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	retention *string
	body *[]string
}

// Retention period for the table segments (e.g. 12h, 3d); If not set, the retention period will default to the first config that&#39;s not null: the table config, then to cluster setting, then &#39;7d&#39;. Using 0d or -1d will instantly delete segments without retention
func (r ApiDeleteSegmentsRequest) Retention(retention string) ApiDeleteSegmentsRequest {
	r.retention = &retention
	return r
}

func (r ApiDeleteSegmentsRequest) Body(body []string) ApiDeleteSegmentsRequest {
	r.body = &body
	return r
}

func (r ApiDeleteSegmentsRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.DeleteSegmentsExecute(r)
}

/*
DeleteSegments Delete the segments in the JSON array payload

Delete the segments in the JSON array payload

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiDeleteSegmentsRequest
*/
func (a *SegmentApiService) DeleteSegments(ctx context.Context, tableName string) ApiDeleteSegmentsRequest {
	return ApiDeleteSegmentsRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *SegmentApiService) DeleteSegmentsExecute(r ApiDeleteSegmentsRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.DeleteSegments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.retention != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "retention", r.retention, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadSegmentRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	segmentName string
}

func (r ApiDownloadSegmentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DownloadSegmentExecute(r)
}

/*
DownloadSegment Download a segment

Download a segment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @param segmentName Name of the segment
 @return ApiDownloadSegmentRequest
*/
func (a *SegmentApiService) DownloadSegment(ctx context.Context, tableName string, segmentName string) ApiDownloadSegmentRequest {
	return ApiDownloadSegmentRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
		segmentName: segmentName,
	}
}

// Execute executes the request
func (a *SegmentApiService) DownloadSegmentExecute(r ApiDownloadSegmentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.DownloadSegment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}/{segmentName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segmentName"+"}", url.PathEscape(parameterValueToString(r.segmentName, "segmentName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndReplaceSegmentsRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	type_ *string
	segmentLineageEntryId *string
}

// OFFLINE|REALTIME
func (r ApiEndReplaceSegmentsRequest) Type_(type_ string) ApiEndReplaceSegmentsRequest {
	r.type_ = &type_
	return r
}

// Segment lineage entry id returned by startReplaceSegments API
func (r ApiEndReplaceSegmentsRequest) SegmentLineageEntryId(segmentLineageEntryId string) ApiEndReplaceSegmentsRequest {
	r.segmentLineageEntryId = &segmentLineageEntryId
	return r
}

func (r ApiEndReplaceSegmentsRequest) Execute() (*http.Response, error) {
	return r.ApiService.EndReplaceSegmentsExecute(r)
}

/*
EndReplaceSegments End to replace segments

End to replace segments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiEndReplaceSegmentsRequest
*/
func (a *SegmentApiService) EndReplaceSegments(ctx context.Context, tableName string) ApiEndReplaceSegmentsRequest {
	return ApiEndReplaceSegmentsRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
func (a *SegmentApiService) EndReplaceSegmentsExecute(r ApiEndReplaceSegmentsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.EndReplaceSegments")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}/endReplaceSegments"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return nil, reportError("type_ is required and must be specified")
	}
	if r.segmentLineageEntryId == nil {
		return nil, reportError("segmentLineageEntryId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLineageEntryId", r.segmentLineageEntryId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetReloadJobStatusRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	jobId string
}

func (r ApiGetReloadJobStatusRequest) Execute() (*ServerReloadControllerJobStatusResponse, *http.Response, error) {
	return r.ApiService.GetReloadJobStatusExecute(r)
}

/*
GetReloadJobStatus Get status for a submitted reload operation

Get status for a submitted reload operation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId Reload job id
 @return ApiGetReloadJobStatusRequest
*/
func (a *SegmentApiService) GetReloadJobStatus(ctx context.Context, jobId string) ApiGetReloadJobStatusRequest {
	return ApiGetReloadJobStatusRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return ServerReloadControllerJobStatusResponse
func (a *SegmentApiService) GetReloadJobStatusExecute(r ApiGetReloadJobStatusRequest) (*ServerReloadControllerJobStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServerReloadControllerJobStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.GetReloadJobStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/segmentReloadStatus/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSegmentMetadataRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	segmentName string
	columns *[]string
}

// Columns name
func (r ApiGetSegmentMetadataRequest) Columns(columns []string) ApiGetSegmentMetadataRequest {
	r.columns = &columns
	return r
}

func (r ApiGetSegmentMetadataRequest) Execute() (map[string]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSegmentMetadataExecute(r)
}

/*
GetSegmentMetadata Get the metadata for a segment

Get the metadata for a segment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @param segmentName Name of the segment
 @return ApiGetSegmentMetadataRequest
*/
func (a *SegmentApiService) GetSegmentMetadata(ctx context.Context, tableName string, segmentName string) ApiGetSegmentMetadataRequest {
	return ApiGetSegmentMetadataRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
		segmentName: segmentName,
	}
}

// Execute executes the request
//  @return map[string]map[string]interface{}
func (a *SegmentApiService) GetSegmentMetadataExecute(r ApiGetSegmentMetadataRequest) (map[string]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.GetSegmentMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}/{segmentName}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segmentName"+"}", url.PathEscape(parameterValueToString(r.segmentName, "segmentName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.columns != nil {
		t := *r.columns
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "columns", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "columns", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSegmentMetadataDeprecated1Request struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	segmentName string
	type_ *string
}

// OFFLINE|REALTIME
func (r ApiGetSegmentMetadataDeprecated1Request) Type_(type_ string) ApiGetSegmentMetadataDeprecated1Request {
	r.type_ = &type_
	return r
}

func (r ApiGetSegmentMetadataDeprecated1Request) Execute() ([][]map[string]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSegmentMetadataDeprecated1Execute(r)
}

/*
GetSegmentMetadataDeprecated1 Get the metadata for a segment (deprecated, use 'GET /segments/{tableName}/{segmentName}/metadata' instead)

Get the metadata for a segment (deprecated, use 'GET /segments/{tableName}/{segmentName}/metadata' instead)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @param segmentName Name of the segment
 @return ApiGetSegmentMetadataDeprecated1Request

Deprecated
*/
func (a *SegmentApiService) GetSegmentMetadataDeprecated1(ctx context.Context, tableName string, segmentName string) ApiGetSegmentMetadataDeprecated1Request {
	return ApiGetSegmentMetadataDeprecated1Request{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
		segmentName: segmentName,
	}
}

// Execute executes the request
//  @return [][]map[string]map[string]interface{}
// Deprecated
func (a *SegmentApiService) GetSegmentMetadataDeprecated1Execute(r ApiGetSegmentMetadataDeprecated1Request) ([][]map[string]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.GetSegmentMetadataDeprecated1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tables/{tableName}/segments/{segmentName}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segmentName"+"}", url.PathEscape(parameterValueToString(r.segmentName, "segmentName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSegmentMetadataDeprecated2Request struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	segmentName string
	state *string
	type_ *string
}

// MUST be null
func (r ApiGetSegmentMetadataDeprecated2Request) State(state string) ApiGetSegmentMetadataDeprecated2Request {
	r.state = &state
	return r
}

// OFFLINE|REALTIME
func (r ApiGetSegmentMetadataDeprecated2Request) Type_(type_ string) ApiGetSegmentMetadataDeprecated2Request {
	r.type_ = &type_
	return r
}

func (r ApiGetSegmentMetadataDeprecated2Request) Execute() ([][]map[string]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetSegmentMetadataDeprecated2Execute(r)
}

/*
GetSegmentMetadataDeprecated2 Get the metadata for a segment (deprecated, use 'GET /segments/{tableName}/{segmentName}/metadata' instead)

Get the metadata for a segment (deprecated, use 'GET /segments/{tableName}/{segmentName}/metadata' instead)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @param segmentName Name of the segment
 @return ApiGetSegmentMetadataDeprecated2Request

Deprecated
*/
func (a *SegmentApiService) GetSegmentMetadataDeprecated2(ctx context.Context, tableName string, segmentName string) ApiGetSegmentMetadataDeprecated2Request {
	return ApiGetSegmentMetadataDeprecated2Request{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
		segmentName: segmentName,
	}
}

// Execute executes the request
//  @return [][]map[string]map[string]interface{}
// Deprecated
func (a *SegmentApiService) GetSegmentMetadataDeprecated2Execute(r ApiGetSegmentMetadataDeprecated2Request) ([][]map[string]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.GetSegmentMetadataDeprecated2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tables/{tableName}/segments/{segmentName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segmentName"+"}", url.PathEscape(parameterValueToString(r.segmentName, "segmentName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSegmentTiersRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	segmentName string
	type_ *string
}

// OFFLINE|REALTIME
func (r ApiGetSegmentTiersRequest) Type_(type_ string) ApiGetSegmentTiersRequest {
	r.type_ = &type_
	return r
}

func (r ApiGetSegmentTiersRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetSegmentTiersExecute(r)
}

/*
GetSegmentTiers Get storage tiers for the given segment

Get storage tiers for the given segment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @param segmentName Name of the segment
 @return ApiGetSegmentTiersRequest
*/
func (a *SegmentApiService) GetSegmentTiers(ctx context.Context, tableName string, segmentName string) ApiGetSegmentTiersRequest {
	return ApiGetSegmentTiersRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
		segmentName: segmentName,
	}
}

// Execute executes the request
func (a *SegmentApiService) GetSegmentTiersExecute(r ApiGetSegmentTiersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.GetSegmentTiers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}/{segmentName}/tiers"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segmentName"+"}", url.PathEscape(parameterValueToString(r.segmentName, "segmentName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSegmentToCrcMapRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
}

func (r ApiGetSegmentToCrcMapRequest) Execute() (map[string]string, *http.Response, error) {
	return r.ApiService.GetSegmentToCrcMapExecute(r)
}

/*
GetSegmentToCrcMap Get a map from segment to CRC of the segment (only apply to OFFLINE table)

Get a map from segment to CRC of the segment (only apply to OFFLINE table)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiGetSegmentToCrcMapRequest
*/
func (a *SegmentApiService) GetSegmentToCrcMap(ctx context.Context, tableName string) ApiGetSegmentToCrcMapRequest {
	return ApiGetSegmentToCrcMapRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
//  @return map[string]string
func (a *SegmentApiService) GetSegmentToCrcMapExecute(r ApiGetSegmentToCrcMapRequest) (map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.GetSegmentToCrcMap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}/crc"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSegmentToCrcMapDeprecatedRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
}

func (r ApiGetSegmentToCrcMapDeprecatedRequest) Execute() (map[string]string, *http.Response, error) {
	return r.ApiService.GetSegmentToCrcMapDeprecatedExecute(r)
}

/*
GetSegmentToCrcMapDeprecated Get a map from segment to CRC of the segment (deprecated, use 'GET /segments/{tableName}/crc' instead)

Get a map from segment to CRC of the segment (deprecated, use 'GET /segments/{tableName}/crc' instead)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiGetSegmentToCrcMapDeprecatedRequest

Deprecated
*/
func (a *SegmentApiService) GetSegmentToCrcMapDeprecated(ctx context.Context, tableName string) ApiGetSegmentToCrcMapDeprecatedRequest {
	return ApiGetSegmentToCrcMapDeprecatedRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
//  @return map[string]string
// Deprecated
func (a *SegmentApiService) GetSegmentToCrcMapDeprecatedExecute(r ApiGetSegmentToCrcMapDeprecatedRequest) (map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.GetSegmentToCrcMapDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tables/{tableName}/segments/crc"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSegmentsRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	type_ *string
	excludeReplacedSegments *string
}

// OFFLINE|REALTIME
func (r ApiGetSegmentsRequest) Type_(type_ string) ApiGetSegmentsRequest {
	r.type_ = &type_
	return r
}

// Whether to exclude replaced segments in the response, which have been replaced specified in the segment lineage entries and cannot be queried from the table
func (r ApiGetSegmentsRequest) ExcludeReplacedSegments(excludeReplacedSegments string) ApiGetSegmentsRequest {
	r.excludeReplacedSegments = &excludeReplacedSegments
	return r
}

func (r ApiGetSegmentsRequest) Execute() ([]map[string][]string, *http.Response, error) {
	return r.ApiService.GetSegmentsExecute(r)
}

/*
GetSegments List all segments. An optional 'excludeReplacedSegments' parameter is used to get the list of segments which has not yet been replaced (determined by segment lineage entries) and can be queried from the table. The value is false by default.

List all segments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiGetSegmentsRequest
*/
func (a *SegmentApiService) GetSegments(ctx context.Context, tableName string) ApiGetSegmentsRequest {
	return ApiGetSegmentsRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
//  @return []map[string][]string
func (a *SegmentApiService) GetSegmentsExecute(r ApiGetSegmentsRequest) ([]map[string][]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string][]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.GetSegments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.excludeReplacedSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeReplacedSegments", r.excludeReplacedSegments, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSelectedSegmentsRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	type_ *string
	startTimestamp *string
	endTimestamp *string
	excludeOverlapping *bool
}

// OFFLINE|REALTIME
func (r ApiGetSelectedSegmentsRequest) Type_(type_ string) ApiGetSelectedSegmentsRequest {
	r.type_ = &type_
	return r
}

// Start timestamp (inclusive)
func (r ApiGetSelectedSegmentsRequest) StartTimestamp(startTimestamp string) ApiGetSelectedSegmentsRequest {
	r.startTimestamp = &startTimestamp
	return r
}

// End timestamp (exclusive)
func (r ApiGetSelectedSegmentsRequest) EndTimestamp(endTimestamp string) ApiGetSelectedSegmentsRequest {
	r.endTimestamp = &endTimestamp
	return r
}

// Whether to exclude the segments overlapping with the timestamps, false by default
func (r ApiGetSelectedSegmentsRequest) ExcludeOverlapping(excludeOverlapping bool) ApiGetSelectedSegmentsRequest {
	r.excludeOverlapping = &excludeOverlapping
	return r
}

func (r ApiGetSelectedSegmentsRequest) Execute() ([]map[string][]string, *http.Response, error) {
	return r.ApiService.GetSelectedSegmentsExecute(r)
}

/*
GetSelectedSegments Get the selected segments given the (inclusive) start and (exclusive) end timestamps in milliseconds. These timestamps will be compared against the minmax values of the time column in each segment. If the table is a refresh use case, the value of start and end timestamp is voided, since there is no time column for refresh use case; instead, the whole qualified segments will be returned. If no timestamps are provided, all the qualified segments will be returned. For the segments that partially belong to the time range, the boolean flag 'excludeOverlapping' is introduced in order for user to determine whether to exclude this kind of segments in the response.

Get the selected segments given the start and end timestamps in milliseconds

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiGetSelectedSegmentsRequest
*/
func (a *SegmentApiService) GetSelectedSegments(ctx context.Context, tableName string) ApiGetSelectedSegmentsRequest {
	return ApiGetSelectedSegmentsRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
//  @return []map[string][]string
func (a *SegmentApiService) GetSelectedSegmentsExecute(r ApiGetSelectedSegmentsRequest) ([]map[string][]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string][]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.GetSelectedSegments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}/select"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.startTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimestamp", r.startTimestamp, "")
	}
	if r.endTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTimestamp", r.endTimestamp, "")
	}
	if r.excludeOverlapping != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeOverlapping", r.excludeOverlapping, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServerMetadataRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	type_ *string
	columns *[]string
}

// OFFLINE|REALTIME
func (r ApiGetServerMetadataRequest) Type_(type_ string) ApiGetServerMetadataRequest {
	r.type_ = &type_
	return r
}

// Columns name
func (r ApiGetServerMetadataRequest) Columns(columns []string) ApiGetServerMetadataRequest {
	r.columns = &columns
	return r
}

func (r ApiGetServerMetadataRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetServerMetadataExecute(r)
}

/*
GetServerMetadata Get the server metadata for all table segments

Get the server metadata for all table segments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiGetServerMetadataRequest
*/
func (a *SegmentApiService) GetServerMetadata(ctx context.Context, tableName string) ApiGetServerMetadataRequest {
	return ApiGetServerMetadataRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
//  @return string
func (a *SegmentApiService) GetServerMetadataExecute(r ApiGetServerMetadataRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.GetServerMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.columns != nil {
		t := *r.columns
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "columns", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "columns", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServerToSegmentsMapRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	type_ *string
}

// OFFLINE|REALTIME
func (r ApiGetServerToSegmentsMapRequest) Type_(type_ string) ApiGetServerToSegmentsMapRequest {
	r.type_ = &type_
	return r
}

func (r ApiGetServerToSegmentsMapRequest) Execute() ([]map[string]map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetServerToSegmentsMapExecute(r)
}

/*
GetServerToSegmentsMap Get a map from server to segments hosted by the server

Get a map from server to segments hosted by the server

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiGetServerToSegmentsMapRequest
*/
func (a *SegmentApiService) GetServerToSegmentsMap(ctx context.Context, tableName string) ApiGetServerToSegmentsMapRequest {
	return ApiGetServerToSegmentsMapRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
//  @return []map[string]map[string]interface{}
func (a *SegmentApiService) GetServerToSegmentsMapExecute(r ApiGetServerToSegmentsMapRequest) ([]map[string]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.GetServerToSegmentsMap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}/servers"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServerToSegmentsMapDeprecated1Request struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	state *string
	type_ *string
}

// MUST be null
func (r ApiGetServerToSegmentsMapDeprecated1Request) State(state string) ApiGetServerToSegmentsMapDeprecated1Request {
	r.state = &state
	return r
}

// OFFLINE|REALTIME
func (r ApiGetServerToSegmentsMapDeprecated1Request) Type_(type_ string) ApiGetServerToSegmentsMapDeprecated1Request {
	r.type_ = &type_
	return r
}

func (r ApiGetServerToSegmentsMapDeprecated1Request) Execute() ([]map[string]string, *http.Response, error) {
	return r.ApiService.GetServerToSegmentsMapDeprecated1Execute(r)
}

/*
GetServerToSegmentsMapDeprecated1 Get a map from server to segments hosted by the server (deprecated, use 'GET /segments/{tableName}/servers' instead)

Get a map from server to segments hosted by the server (deprecated, use 'GET /segments/{tableName}/servers' instead)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiGetServerToSegmentsMapDeprecated1Request

Deprecated
*/
func (a *SegmentApiService) GetServerToSegmentsMapDeprecated1(ctx context.Context, tableName string) ApiGetServerToSegmentsMapDeprecated1Request {
	return ApiGetServerToSegmentsMapDeprecated1Request{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
//  @return []map[string]string
// Deprecated
func (a *SegmentApiService) GetServerToSegmentsMapDeprecated1Execute(r ApiGetServerToSegmentsMapDeprecated1Request) ([]map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.GetServerToSegmentsMapDeprecated1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tables/{tableName}/segments"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServerToSegmentsMapDeprecated2Request struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	state *string
	type_ *string
}

// MUST be null
func (r ApiGetServerToSegmentsMapDeprecated2Request) State(state string) ApiGetServerToSegmentsMapDeprecated2Request {
	r.state = &state
	return r
}

// OFFLINE|REALTIME
func (r ApiGetServerToSegmentsMapDeprecated2Request) Type_(type_ string) ApiGetServerToSegmentsMapDeprecated2Request {
	r.type_ = &type_
	return r
}

func (r ApiGetServerToSegmentsMapDeprecated2Request) Execute() ([]map[string]string, *http.Response, error) {
	return r.ApiService.GetServerToSegmentsMapDeprecated2Execute(r)
}

/*
GetServerToSegmentsMapDeprecated2 Get a map from server to segments hosted by the server (deprecated, use 'GET /segments/{tableName}/servers' instead)

Get a map from server to segments hosted by the server (deprecated, use 'GET /segments/{tableName}/servers' instead)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiGetServerToSegmentsMapDeprecated2Request

Deprecated
*/
func (a *SegmentApiService) GetServerToSegmentsMapDeprecated2(ctx context.Context, tableName string) ApiGetServerToSegmentsMapDeprecated2Request {
	return ApiGetServerToSegmentsMapDeprecated2Request{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
//  @return []map[string]string
// Deprecated
func (a *SegmentApiService) GetServerToSegmentsMapDeprecated2Execute(r ApiGetServerToSegmentsMapDeprecated2Request) ([]map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.GetServerToSegmentsMapDeprecated2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tables/{tableName}/segments/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTableTiersRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	type_ *string
}

// OFFLINE|REALTIME
func (r ApiGetTableTiersRequest) Type_(type_ string) ApiGetTableTiersRequest {
	r.type_ = &type_
	return r
}

func (r ApiGetTableTiersRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetTableTiersExecute(r)
}

/*
GetTableTiers Get storage tier for all segments in the given table

Get storage tier for all segments in the given table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiGetTableTiersRequest
*/
func (a *SegmentApiService) GetTableTiers(ctx context.Context, tableName string) ApiGetTableTiersRequest {
	return ApiGetTableTiersRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
func (a *SegmentApiService) GetTableTiersExecute(r ApiGetTableTiersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.GetTableTiers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}/tiers"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetZookeeperMetadataRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	type_ *string
}

// OFFLINE|REALTIME
func (r ApiGetZookeeperMetadataRequest) Type_(type_ string) ApiGetZookeeperMetadataRequest {
	r.type_ = &type_
	return r
}

func (r ApiGetZookeeperMetadataRequest) Execute() (*map[string]map[string]string, *http.Response, error) {
	return r.ApiService.GetZookeeperMetadataExecute(r)
}

/*
GetZookeeperMetadata Get the zookeeper metadata for all table segments

Get the zookeeper metadata for all table segments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiGetZookeeperMetadataRequest
*/
func (a *SegmentApiService) GetZookeeperMetadata(ctx context.Context, tableName string) ApiGetZookeeperMetadataRequest {
	return ApiGetZookeeperMetadataRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
//  @return map[string]map[string]string
func (a *SegmentApiService) GetZookeeperMetadataExecute(r ApiGetZookeeperMetadataRequest) (*map[string]map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.GetZookeeperMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}/zkmetadata"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSegmentLineageRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	type_ *string
}

// OFFLINE|REALTIME
func (r ApiListSegmentLineageRequest) Type_(type_ string) ApiListSegmentLineageRequest {
	r.type_ = &type_
	return r
}

func (r ApiListSegmentLineageRequest) Execute() (*http.Response, error) {
	return r.ApiService.ListSegmentLineageExecute(r)
}

/*
ListSegmentLineage List segment lineage

List segment lineage in chronologically sorted order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiListSegmentLineageRequest
*/
func (a *SegmentApiService) ListSegmentLineage(ctx context.Context, tableName string) ApiListSegmentLineageRequest {
	return ApiListSegmentLineageRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
func (a *SegmentApiService) ListSegmentLineageExecute(r ApiListSegmentLineageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.ListSegmentLineage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}/lineage"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReloadAllSegmentsRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	type_ *string
	forceDownload *bool
}

// OFFLINE|REALTIME
func (r ApiReloadAllSegmentsRequest) Type_(type_ string) ApiReloadAllSegmentsRequest {
	r.type_ = &type_
	return r
}

// Whether to force server to download segment
func (r ApiReloadAllSegmentsRequest) ForceDownload(forceDownload bool) ApiReloadAllSegmentsRequest {
	r.forceDownload = &forceDownload
	return r
}

func (r ApiReloadAllSegmentsRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ReloadAllSegmentsExecute(r)
}

/*
ReloadAllSegments Reload all segments

Reload all segments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiReloadAllSegmentsRequest
*/
func (a *SegmentApiService) ReloadAllSegments(ctx context.Context, tableName string) ApiReloadAllSegmentsRequest {
	return ApiReloadAllSegmentsRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *SegmentApiService) ReloadAllSegmentsExecute(r ApiReloadAllSegmentsRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.ReloadAllSegments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}/reload"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.forceDownload != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forceDownload", r.forceDownload, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReloadAllSegmentsDeprecated1Request struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	type_ *string
}

// OFFLINE|REALTIME
func (r ApiReloadAllSegmentsDeprecated1Request) Type_(type_ string) ApiReloadAllSegmentsDeprecated1Request {
	r.type_ = &type_
	return r
}

func (r ApiReloadAllSegmentsDeprecated1Request) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ReloadAllSegmentsDeprecated1Execute(r)
}

/*
ReloadAllSegmentsDeprecated1 Reload all segments (deprecated, use 'POST /segments/{tableName}/reload' instead)

Reload all segments (deprecated, use 'POST /segments/{tableName}/reload' instead)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiReloadAllSegmentsDeprecated1Request

Deprecated
*/
func (a *SegmentApiService) ReloadAllSegmentsDeprecated1(ctx context.Context, tableName string) ApiReloadAllSegmentsDeprecated1Request {
	return ApiReloadAllSegmentsDeprecated1Request{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
//  @return SuccessResponse
// Deprecated
func (a *SegmentApiService) ReloadAllSegmentsDeprecated1Execute(r ApiReloadAllSegmentsDeprecated1Request) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.ReloadAllSegmentsDeprecated1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tables/{tableName}/segments/reload"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReloadAllSegmentsDeprecated2Request struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	type_ *string
}

// OFFLINE|REALTIME
func (r ApiReloadAllSegmentsDeprecated2Request) Type_(type_ string) ApiReloadAllSegmentsDeprecated2Request {
	r.type_ = &type_
	return r
}

func (r ApiReloadAllSegmentsDeprecated2Request) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ReloadAllSegmentsDeprecated2Execute(r)
}

/*
ReloadAllSegmentsDeprecated2 Reload all segments (deprecated, use 'POST /segments/{tableName}/reload' instead)

Reload all segments (deprecated, use 'POST /segments/{tableName}/reload' instead)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiReloadAllSegmentsDeprecated2Request

Deprecated
*/
func (a *SegmentApiService) ReloadAllSegmentsDeprecated2(ctx context.Context, tableName string) ApiReloadAllSegmentsDeprecated2Request {
	return ApiReloadAllSegmentsDeprecated2Request{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
//  @return SuccessResponse
// Deprecated
func (a *SegmentApiService) ReloadAllSegmentsDeprecated2Execute(r ApiReloadAllSegmentsDeprecated2Request) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.ReloadAllSegmentsDeprecated2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tables/{tableName}/segments/reload"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReloadSegmentRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	segmentName string
	forceDownload *bool
}

// Whether to force server to download segment
func (r ApiReloadSegmentRequest) ForceDownload(forceDownload bool) ApiReloadSegmentRequest {
	r.forceDownload = &forceDownload
	return r
}

func (r ApiReloadSegmentRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ReloadSegmentExecute(r)
}

/*
ReloadSegment Reload a segment

Reload a segment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @param segmentName Name of the segment
 @return ApiReloadSegmentRequest
*/
func (a *SegmentApiService) ReloadSegment(ctx context.Context, tableName string, segmentName string) ApiReloadSegmentRequest {
	return ApiReloadSegmentRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
		segmentName: segmentName,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *SegmentApiService) ReloadSegmentExecute(r ApiReloadSegmentRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.ReloadSegment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}/{segmentName}/reload"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segmentName"+"}", url.PathEscape(parameterValueToString(r.segmentName, "segmentName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.forceDownload != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forceDownload", r.forceDownload, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReloadSegmentDeprecated1Request struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	segmentName string
	type_ *string
}

// OFFLINE|REALTIME
func (r ApiReloadSegmentDeprecated1Request) Type_(type_ string) ApiReloadSegmentDeprecated1Request {
	r.type_ = &type_
	return r
}

func (r ApiReloadSegmentDeprecated1Request) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ReloadSegmentDeprecated1Execute(r)
}

/*
ReloadSegmentDeprecated1 Reload a segment (deprecated, use 'POST /segments/{tableName}/{segmentName}/reload' instead)

Reload a segment (deprecated, use 'POST /segments/{tableName}/{segmentName}/reload' instead)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @param segmentName Name of the segment
 @return ApiReloadSegmentDeprecated1Request

Deprecated
*/
func (a *SegmentApiService) ReloadSegmentDeprecated1(ctx context.Context, tableName string, segmentName string) ApiReloadSegmentDeprecated1Request {
	return ApiReloadSegmentDeprecated1Request{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
		segmentName: segmentName,
	}
}

// Execute executes the request
//  @return SuccessResponse
// Deprecated
func (a *SegmentApiService) ReloadSegmentDeprecated1Execute(r ApiReloadSegmentDeprecated1Request) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.ReloadSegmentDeprecated1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tables/{tableName}/segments/{segmentName}/reload"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segmentName"+"}", url.PathEscape(parameterValueToString(r.segmentName, "segmentName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReloadSegmentDeprecated2Request struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	segmentName string
	type_ *string
}

// OFFLINE|REALTIME
func (r ApiReloadSegmentDeprecated2Request) Type_(type_ string) ApiReloadSegmentDeprecated2Request {
	r.type_ = &type_
	return r
}

func (r ApiReloadSegmentDeprecated2Request) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ReloadSegmentDeprecated2Execute(r)
}

/*
ReloadSegmentDeprecated2 Reload a segment (deprecated, use 'POST /segments/{tableName}/{segmentName}/reload' instead)

Reload a segment (deprecated, use 'POST /segments/{tableName}/{segmentName}/reload' instead)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @param segmentName Name of the segment
 @return ApiReloadSegmentDeprecated2Request

Deprecated
*/
func (a *SegmentApiService) ReloadSegmentDeprecated2(ctx context.Context, tableName string, segmentName string) ApiReloadSegmentDeprecated2Request {
	return ApiReloadSegmentDeprecated2Request{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
		segmentName: segmentName,
	}
}

// Execute executes the request
//  @return SuccessResponse
// Deprecated
func (a *SegmentApiService) ReloadSegmentDeprecated2Execute(r ApiReloadSegmentDeprecated2Request) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.ReloadSegmentDeprecated2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tables/{tableName}/segments/{segmentName}/reload"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segmentName"+"}", url.PathEscape(parameterValueToString(r.segmentName, "segmentName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetSegmentRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableNameWithType string
	segmentName string
	targetInstance *string
}

// Name of the target instance to reset
func (r ApiResetSegmentRequest) TargetInstance(targetInstance string) ApiResetSegmentRequest {
	r.targetInstance = &targetInstance
	return r
}

func (r ApiResetSegmentRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ResetSegmentExecute(r)
}

/*
ResetSegment Resets a segment by first disabling it, waiting for external view to stabilize, and finally enabling it again

Resets a segment by disabling and then enabling it

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableNameWithType Name of the table with type
 @param segmentName Name of the segment
 @return ApiResetSegmentRequest
*/
func (a *SegmentApiService) ResetSegment(ctx context.Context, tableNameWithType string, segmentName string) ApiResetSegmentRequest {
	return ApiResetSegmentRequest{
		ApiService: a,
		ctx: ctx,
		tableNameWithType: tableNameWithType,
		segmentName: segmentName,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *SegmentApiService) ResetSegmentExecute(r ApiResetSegmentRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.ResetSegment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableNameWithType}/{segmentName}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"tableNameWithType"+"}", url.PathEscape(parameterValueToString(r.tableNameWithType, "tableNameWithType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segmentName"+"}", url.PathEscape(parameterValueToString(r.segmentName, "segmentName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.targetInstance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "targetInstance", r.targetInstance, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetSegmentsRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableNameWithType string
	targetInstance *string
	errorSegmentsOnly *bool
}

// Name of the target instance to reset
func (r ApiResetSegmentsRequest) TargetInstance(targetInstance string) ApiResetSegmentsRequest {
	r.targetInstance = &targetInstance
	return r
}

// Whether to reset only segments with error state
func (r ApiResetSegmentsRequest) ErrorSegmentsOnly(errorSegmentsOnly bool) ApiResetSegmentsRequest {
	r.errorSegmentsOnly = &errorSegmentsOnly
	return r
}

func (r ApiResetSegmentsRequest) Execute() (*SuccessResponse, *http.Response, error) {
	return r.ApiService.ResetSegmentsExecute(r)
}

/*
ResetSegments Resets all segments (when errorSegmentsOnly = false) or segments with Error state (when errorSegmentsOnly = true) of the table, by first disabling them, waiting for external view to stabilize, and finally enabling them

Resets segments by disabling and then enabling them

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableNameWithType Name of the table with type
 @return ApiResetSegmentsRequest
*/
func (a *SegmentApiService) ResetSegments(ctx context.Context, tableNameWithType string) ApiResetSegmentsRequest {
	return ApiResetSegmentsRequest{
		ApiService: a,
		ctx: ctx,
		tableNameWithType: tableNameWithType,
	}
}

// Execute executes the request
//  @return SuccessResponse
func (a *SegmentApiService) ResetSegmentsExecute(r ApiResetSegmentsRequest) (*SuccessResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SuccessResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.ResetSegments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableNameWithType}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"tableNameWithType"+"}", url.PathEscape(parameterValueToString(r.tableNameWithType, "tableNameWithType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.targetInstance != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "targetInstance", r.targetInstance, "")
	}
	if r.errorSegmentsOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "errorSegmentsOnly", r.errorSegmentsOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRevertReplaceSegmentsRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	type_ *string
	segmentLineageEntryId *string
	forceRevert *bool
}

// OFFLINE|REALTIME
func (r ApiRevertReplaceSegmentsRequest) Type_(type_ string) ApiRevertReplaceSegmentsRequest {
	r.type_ = &type_
	return r
}

// Segment lineage entry id to revert
func (r ApiRevertReplaceSegmentsRequest) SegmentLineageEntryId(segmentLineageEntryId string) ApiRevertReplaceSegmentsRequest {
	r.segmentLineageEntryId = &segmentLineageEntryId
	return r
}

// Force revert in case the user knows that the lineage entry is interrupted
func (r ApiRevertReplaceSegmentsRequest) ForceRevert(forceRevert bool) ApiRevertReplaceSegmentsRequest {
	r.forceRevert = &forceRevert
	return r
}

func (r ApiRevertReplaceSegmentsRequest) Execute() (*http.Response, error) {
	return r.ApiService.RevertReplaceSegmentsExecute(r)
}

/*
RevertReplaceSegments Revert segments replacement

Revert segments replacement

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiRevertReplaceSegmentsRequest
*/
func (a *SegmentApiService) RevertReplaceSegments(ctx context.Context, tableName string) ApiRevertReplaceSegmentsRequest {
	return ApiRevertReplaceSegmentsRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
func (a *SegmentApiService) RevertReplaceSegmentsExecute(r ApiRevertReplaceSegmentsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.RevertReplaceSegments")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}/revertReplaceSegments"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return nil, reportError("type_ is required and must be specified")
	}
	if r.segmentLineageEntryId == nil {
		return nil, reportError("segmentLineageEntryId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLineageEntryId", r.segmentLineageEntryId, "")
	if r.forceRevert != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forceRevert", r.forceRevert, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStartReplaceSegmentsRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName string
	type_ *string
	body *StartReplaceSegmentsRequest
	forceCleanup *bool
}

// OFFLINE|REALTIME
func (r ApiStartReplaceSegmentsRequest) Type_(type_ string) ApiStartReplaceSegmentsRequest {
	r.type_ = &type_
	return r
}

// Fields belonging to start replace segment request
func (r ApiStartReplaceSegmentsRequest) Body(body StartReplaceSegmentsRequest) ApiStartReplaceSegmentsRequest {
	r.body = &body
	return r
}

// Force cleanup
func (r ApiStartReplaceSegmentsRequest) ForceCleanup(forceCleanup bool) ApiStartReplaceSegmentsRequest {
	r.forceCleanup = &forceCleanup
	return r
}

func (r ApiStartReplaceSegmentsRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartReplaceSegmentsExecute(r)
}

/*
StartReplaceSegments Start to replace segments

Start to replace segments

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableName Name of the table
 @return ApiStartReplaceSegmentsRequest
*/
func (a *SegmentApiService) StartReplaceSegments(ctx context.Context, tableName string) ApiStartReplaceSegmentsRequest {
	return ApiStartReplaceSegmentsRequest{
		ApiService: a,
		ctx: ctx,
		tableName: tableName,
	}
}

// Execute executes the request
func (a *SegmentApiService) StartReplaceSegmentsExecute(r ApiStartReplaceSegmentsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.StartReplaceSegments")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableName}/startReplaceSegments"
	localVarPath = strings.Replace(localVarPath, "{"+"tableName"+"}", url.PathEscape(parameterValueToString(r.tableName, "tableName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.type_ == nil {
		return nil, reportError("type_ is required and must be specified")
	}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	if r.forceCleanup != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forceCleanup", r.forceCleanup, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateTimeIntervalZKRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableNameWithType string
}

func (r ApiUpdateTimeIntervalZKRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateTimeIntervalZKExecute(r)
}

/*
UpdateTimeIntervalZK Update the start and end time of the segments based on latest schema

Update the start and end time of the segments based on latest schema

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tableNameWithType Table name with type
 @return ApiUpdateTimeIntervalZKRequest
*/
func (a *SegmentApiService) UpdateTimeIntervalZK(ctx context.Context, tableNameWithType string) ApiUpdateTimeIntervalZKRequest {
	return ApiUpdateTimeIntervalZKRequest{
		ApiService: a,
		ctx: ctx,
		tableNameWithType: tableNameWithType,
	}
}

// Execute executes the request
func (a *SegmentApiService) UpdateTimeIntervalZKExecute(r ApiUpdateTimeIntervalZKRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.UpdateTimeIntervalZK")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments/{tableNameWithType}/updateZKTimeInterval"
	localVarPath = strings.Replace(localVarPath, "{"+"tableNameWithType"+"}", url.PathEscape(parameterValueToString(r.tableNameWithType, "tableNameWithType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUploadSegmentAsMultiPartRequest struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName *string
	tableType *string
	enableParallelPushProtection *bool
	allowRefresh *bool
	contentDisposition *ContentDisposition
	entity *map[string]interface{}
	mediaType *MediaType
	messageBodyWorkers *map[string]interface{}
	parent *MultiPart
	providers *map[string]interface{}
	bodyParts *[]BodyPart
}

// Name of the table
func (r ApiUploadSegmentAsMultiPartRequest) TableName(tableName string) ApiUploadSegmentAsMultiPartRequest {
	r.tableName = &tableName
	return r
}

// Type of the table
func (r ApiUploadSegmentAsMultiPartRequest) TableType(tableType string) ApiUploadSegmentAsMultiPartRequest {
	r.tableType = &tableType
	return r
}

// Whether to enable parallel push protection
func (r ApiUploadSegmentAsMultiPartRequest) EnableParallelPushProtection(enableParallelPushProtection bool) ApiUploadSegmentAsMultiPartRequest {
	r.enableParallelPushProtection = &enableParallelPushProtection
	return r
}

// Whether to refresh if the segment already exists
func (r ApiUploadSegmentAsMultiPartRequest) AllowRefresh(allowRefresh bool) ApiUploadSegmentAsMultiPartRequest {
	r.allowRefresh = &allowRefresh
	return r
}

func (r ApiUploadSegmentAsMultiPartRequest) ContentDisposition(contentDisposition ContentDisposition) ApiUploadSegmentAsMultiPartRequest {
	r.contentDisposition = &contentDisposition
	return r
}

func (r ApiUploadSegmentAsMultiPartRequest) Entity(entity map[string]interface{}) ApiUploadSegmentAsMultiPartRequest {
	r.entity = &entity
	return r
}

func (r ApiUploadSegmentAsMultiPartRequest) MediaType(mediaType MediaType) ApiUploadSegmentAsMultiPartRequest {
	r.mediaType = &mediaType
	return r
}

func (r ApiUploadSegmentAsMultiPartRequest) MessageBodyWorkers(messageBodyWorkers map[string]interface{}) ApiUploadSegmentAsMultiPartRequest {
	r.messageBodyWorkers = &messageBodyWorkers
	return r
}

func (r ApiUploadSegmentAsMultiPartRequest) Parent(parent MultiPart) ApiUploadSegmentAsMultiPartRequest {
	r.parent = &parent
	return r
}

func (r ApiUploadSegmentAsMultiPartRequest) Providers(providers map[string]interface{}) ApiUploadSegmentAsMultiPartRequest {
	r.providers = &providers
	return r
}

func (r ApiUploadSegmentAsMultiPartRequest) BodyParts(bodyParts []BodyPart) ApiUploadSegmentAsMultiPartRequest {
	r.bodyParts = &bodyParts
	return r
}

func (r ApiUploadSegmentAsMultiPartRequest) Execute() (*http.Response, error) {
	return r.ApiService.UploadSegmentAsMultiPartExecute(r)
}

/*
UploadSegmentAsMultiPart Upload a segment

Upload a segment as binary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUploadSegmentAsMultiPartRequest
*/
func (a *SegmentApiService) UploadSegmentAsMultiPart(ctx context.Context) ApiUploadSegmentAsMultiPartRequest {
	return ApiUploadSegmentAsMultiPartRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SegmentApiService) UploadSegmentAsMultiPartExecute(r ApiUploadSegmentAsMultiPartRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.UploadSegmentAsMultiPart")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tableName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tableName", r.tableName, "")
	}
	if r.tableType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tableType", r.tableType, "")
	}
	if r.enableParallelPushProtection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableParallelPushProtection", r.enableParallelPushProtection, "")
	}
	if r.allowRefresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowRefresh", r.allowRefresh, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.contentDisposition != nil {
		paramJson, err := parameterToJson(*r.contentDisposition)
		if err != nil {
			return nil, err
		}
		localVarFormParams.Add("contentDisposition", paramJson)
	}
	if r.entity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "entity", r.entity, "")
	}
	if r.mediaType != nil {
		paramJson, err := parameterToJson(*r.mediaType)
		if err != nil {
			return nil, err
		}
		localVarFormParams.Add("mediaType", paramJson)
	}
	if r.messageBodyWorkers != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "messageBodyWorkers", r.messageBodyWorkers, "")
	}
	if r.parent != nil {
		paramJson, err := parameterToJson(*r.parent)
		if err != nil {
			return nil, err
		}
		localVarFormParams.Add("parent", paramJson)
	}
	if r.providers != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "providers", r.providers, "")
	}
	if r.bodyParts != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "bodyParts", r.bodyParts, "csv")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUploadSegmentAsMultiPartV2Request struct {
	ctx context.Context
	ApiService *SegmentApiService
	tableName *string
	tableType *string
	enableParallelPushProtection *bool
	allowRefresh *bool
	contentDisposition *ContentDisposition
	entity *map[string]interface{}
	mediaType *MediaType
	messageBodyWorkers *map[string]interface{}
	parent *MultiPart
	providers *map[string]interface{}
	bodyParts *[]BodyPart
}

// Name of the table
func (r ApiUploadSegmentAsMultiPartV2Request) TableName(tableName string) ApiUploadSegmentAsMultiPartV2Request {
	r.tableName = &tableName
	return r
}

// Type of the table
func (r ApiUploadSegmentAsMultiPartV2Request) TableType(tableType string) ApiUploadSegmentAsMultiPartV2Request {
	r.tableType = &tableType
	return r
}

// Whether to enable parallel push protection
func (r ApiUploadSegmentAsMultiPartV2Request) EnableParallelPushProtection(enableParallelPushProtection bool) ApiUploadSegmentAsMultiPartV2Request {
	r.enableParallelPushProtection = &enableParallelPushProtection
	return r
}

// Whether to refresh if the segment already exists
func (r ApiUploadSegmentAsMultiPartV2Request) AllowRefresh(allowRefresh bool) ApiUploadSegmentAsMultiPartV2Request {
	r.allowRefresh = &allowRefresh
	return r
}

func (r ApiUploadSegmentAsMultiPartV2Request) ContentDisposition(contentDisposition ContentDisposition) ApiUploadSegmentAsMultiPartV2Request {
	r.contentDisposition = &contentDisposition
	return r
}

func (r ApiUploadSegmentAsMultiPartV2Request) Entity(entity map[string]interface{}) ApiUploadSegmentAsMultiPartV2Request {
	r.entity = &entity
	return r
}

func (r ApiUploadSegmentAsMultiPartV2Request) MediaType(mediaType MediaType) ApiUploadSegmentAsMultiPartV2Request {
	r.mediaType = &mediaType
	return r
}

func (r ApiUploadSegmentAsMultiPartV2Request) MessageBodyWorkers(messageBodyWorkers map[string]interface{}) ApiUploadSegmentAsMultiPartV2Request {
	r.messageBodyWorkers = &messageBodyWorkers
	return r
}

func (r ApiUploadSegmentAsMultiPartV2Request) Parent(parent MultiPart) ApiUploadSegmentAsMultiPartV2Request {
	r.parent = &parent
	return r
}

func (r ApiUploadSegmentAsMultiPartV2Request) Providers(providers map[string]interface{}) ApiUploadSegmentAsMultiPartV2Request {
	r.providers = &providers
	return r
}

func (r ApiUploadSegmentAsMultiPartV2Request) BodyParts(bodyParts []BodyPart) ApiUploadSegmentAsMultiPartV2Request {
	r.bodyParts = &bodyParts
	return r
}

func (r ApiUploadSegmentAsMultiPartV2Request) Execute() (*http.Response, error) {
	return r.ApiService.UploadSegmentAsMultiPartV2Execute(r)
}

/*
UploadSegmentAsMultiPartV2 Upload a segment

Upload a segment as binary

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUploadSegmentAsMultiPartV2Request
*/
func (a *SegmentApiService) UploadSegmentAsMultiPartV2(ctx context.Context) ApiUploadSegmentAsMultiPartV2Request {
	return ApiUploadSegmentAsMultiPartV2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SegmentApiService) UploadSegmentAsMultiPartV2Execute(r ApiUploadSegmentAsMultiPartV2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SegmentApiService.UploadSegmentAsMultiPartV2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/segments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tableName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tableName", r.tableName, "")
	}
	if r.tableType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tableType", r.tableType, "")
	}
	if r.enableParallelPushProtection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableParallelPushProtection", r.enableParallelPushProtection, "")
	}
	if r.allowRefresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowRefresh", r.allowRefresh, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.contentDisposition != nil {
		paramJson, err := parameterToJson(*r.contentDisposition)
		if err != nil {
			return nil, err
		}
		localVarFormParams.Add("contentDisposition", paramJson)
	}
	if r.entity != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "entity", r.entity, "")
	}
	if r.mediaType != nil {
		paramJson, err := parameterToJson(*r.mediaType)
		if err != nil {
			return nil, err
		}
		localVarFormParams.Add("mediaType", paramJson)
	}
	if r.messageBodyWorkers != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "messageBodyWorkers", r.messageBodyWorkers, "")
	}
	if r.parent != nil {
		paramJson, err := parameterToJson(*r.parent)
		if err != nil {
			return nil, err
		}
		localVarFormParams.Add("parent", paramJson)
	}
	if r.providers != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "providers", r.providers, "")
	}
	if r.bodyParts != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "bodyParts", r.bodyParts, "csv")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["oauth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
